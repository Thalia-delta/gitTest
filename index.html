<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>极简主界面</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* 加载动画样式 */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .loading-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    /* 吉祥物动画 */
    .mascot-animation {
      width: 80px;
      height: 80px;
    }

    .mascot-animation img {
      width: 100%;
      height: 100%;
      animation: float 2s ease-in-out infinite;
    }

    /* 三个点动画 */
    .dots-animation {
      display: flex;
      gap: 8px;
    }

    .dots-animation .dot {
      width: 10px;
      height: 10px;
      background-color: #333;
      border-radius: 50%;
      animation: float 1.5s ease-in-out infinite;
    }

    .dots-animation .dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .dots-animation .dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    /* 加载文字 */
    .loading-text {
      font-size: 18px;
      color: #333;
      margin-top: 0.5rem;
    }

    /* 浮动动画 */
    @keyframes float {
      0%, 100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-10px);
      }
    }
  </style>
</head>

<body>
  <!-- 顶部导航 - 悬浮按钮样式 -->
  <header class="top-nav">
    <div class="nav-toggle" id="navToggle">
      <span class="toggle-icon">☰</span>
    </div>
    <div class="nav-dropdown" id="navDropdown">
      <span class="nav-item active">主界面</span>
      <span class="nav-item" onclick="window.location.href='album.html'">相册集</span>
      <span class="nav-item" onclick="window.location.href='profile.html'">我的</span>
    </div>
  </header>

  <!-- 上传加载动画 -->
  <div class="loading-overlay" id="uploadLoading">
    <div class="loading-content">
      <div class="mascot-animation">
        <img src="Picture\草裙.png" alt="吉祥物">
      </div>
      <div class="dots-animation">
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
      </div>
      <p class="loading-text">加载中...</p>
    </div>
  </div>

  <!-- 大模型分析加载动画 -->
  <div class="loading-overlay" id="analysisLoading">
    <div class="loading-content">
      <div class="mascot-animation">
        <img src="Picture\草裙.png" alt="吉祥物">
      </div>
      <div class="dots-animation">
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
      </div>
      <p class="loading-text">AI分析中...</p>
    </div>
  </div>

  <!-- 主体 -->
  <main class="main">
    <!-- 吉祥物 -->
    <div class="mascot">
      <img src="Picture\草裙.png" alt="mascot">
    </div>

    <!-- 文案 -->
    <p class="greeting">“hi，又去哪里玩了呀？”</p>

    <!-- 滑动卡片 -->
    <div class="card-slider">
      <!-- 左侧滑动提示 -->
      <div class="swipe-hint left">
        <span class="hint-text">左右滑动</span>
        <span class="hint-arrow"><<<</span>
      </div>
      
      <div class="card-container">
        <div class="card new-card" onclick="openPhotoUpload()">
          <span class="plus">＋</span>
          <span>新建回忆</span>
          <input type="file" id="photoInput" multiple accept="image/*" style="display: none;" onchange="handlePhotoUpload(this.files)">
        </div>

      <div class="card">
        <p>上次的旅行</p>
      </div>

      <div class="card">
        <p>周末随拍</p>
      </div>
      
      <div class="card">
        <p>毕业纪念</p>
      </div>
      
      <div class="card">
        <p>美食记录</p>
      </div>
      
      <div class="card">
        <p>城市风光</p>
      </div>
      
      <div class="card">
        <p>自然风景</p>
      </div>
      
      <div class="card">
        <p>家庭聚会</p>
      </div>
      </div>
      
      <!-- 右侧滑动提示 -->
      <div class="swipe-hint right">
        <span class="hint-text">左右滑动</span>
        <span class="hint-arrow">>>></span>
      </div>
    </div>
  </main>

  <script>
    // 导航菜单功能
    const navToggle = document.getElementById('navToggle');
    const navDropdown = document.getElementById('navDropdown');
    let isDropdownOpen = false;
    
    // 切换下拉菜单显示状态
    navToggle.addEventListener('click', () => {
      isDropdownOpen = !isDropdownOpen;
      navDropdown.classList.toggle('show', isDropdownOpen);
    });
    
    // 点击页面其他地方关闭下拉菜单
    document.addEventListener('click', (e) => {
      if (!navToggle.contains(e.target) && !navDropdown.contains(e.target)) {
        isDropdownOpen = false;
        navDropdown.classList.remove('show');
      }
    });

    // 照片上传功能
    function openPhotoUpload() {
      document.getElementById('photoInput').click();
    }

    // IndexedDB 相关函数
    const DB_NAME = 'TravelPhotosDB';
    const DB_VERSION = 3; // 增加版本号以支持新索引
    const STORE_NAME = 'photos';
    
    // 打开 IndexedDB 数据库
    function openDB() {
      return new Promise((resolve, reject) => {
        // 检查indexedDB对象是否可用
        if (!window.indexedDB) {
          reject('您的浏览器不支持IndexedDB');
          return;
        }
        
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          let store;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
          } else {
            store = event.target.transaction.objectStore(STORE_NAME);
          }
          // 创建索引以便按photosKey查询
          if (!store.indexNames.contains('by_photosKey')) {
            store.createIndex('by_photosKey', 'photosKey');
          }
        };
        
        request.onsuccess = (event) => {
          resolve(event.target.result);
        };
        
        request.onerror = (event) => {
          const error = event.target.error || { name: '未知错误' };
          reject('打开数据库失败: ' + error.name);
        };
      });
    }
    
    // 清空所有照片数据
    async function clearAllPhotosData() {
      try {
        const db = await openDB();
        const transaction = db.transaction(STORE_NAME, 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.clear();
        
        request.onsuccess = () => {
          console.log('已清理所有照片数据');
        };
        
        request.onerror = (error) => {
          console.error('清理照片数据失败:', error);
        };
      } catch (error) {
        console.error('清理照片数据失败:', error);
      }
    }
    
    // 从IndexedDB获取照片数据
    async function getPhotosFromIndexedDB() {
      try {
        const db = await openDB();
        const transaction = db.transaction(STORE_NAME, 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.getAll();
        
        return new Promise((resolve, reject) => {
          request.onsuccess = (event) => {
            resolve(event.target.result);
          };
          
          request.onerror = (error) => {
            reject('获取照片数据失败: ' + error);
          };
        });
      } catch (error) {
        console.error('从IndexedDB获取照片数据失败:', error);
        return null;
      }
    }
    
    async function handlePhotoUpload(files) {
      if (!files || files.length === 0) {
        console.log('没有选择照片');
        return;
      }
      
      console.log('开始处理照片...');
      console.log('选中的照片数量:', files.length);
      
      // 显示上传加载动画
      document.getElementById('uploadLoading').style.display = 'flex';
      
      // 清空所有之前存储的照片数据
      await clearAllPhotosData();
      
      const photoData = [];
      let processedCount = 0;
      
      // 打开数据库连接
      const db = await openDB();
      
      // 处理每张照片
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        console.log(`处理照片 ${i+1}/${files.length}: ${file.name}, 大小: ${(file.size/1024/1024).toFixed(2)}MB`);
        
        // 读取文件并存储到IndexedDB，不压缩以保留EXIF信息
        const reader = new FileReader();
        
        reader.onload = (e) => {
          const photo = {
            id: i,
            name: file.name,
            size: file.size,
            type: file.type,
            data: e.target.result,
            photosKey: 'indexedDB' // 添加photosKey字段
          };
          
          // 存储到IndexedDB
          const transaction = db.transaction(STORE_NAME, 'readwrite');
          const store = transaction.objectStore(STORE_NAME);
          const request = store.add(photo);
          
          request.onsuccess = () => {
            console.log(`照片 ${i+1} 已存储到IndexedDB`);
            photoData.push(photo);
            processedCount++;
            
            // 所有照片处理完成
            if (processedCount === files.length) {
              console.log('所有照片处理完成，开始发送请求...');
              
              try {
                // 计算数据大小
                const dataSize = (photoData.reduce((total, photo) => total + photo.data.length, 0) * 2) / 1024 / 1024;
                console.log('照片数据大小:', dataSize.toFixed(2), 'MB');
                
                // 隐藏上传加载动画
                document.getElementById('uploadLoading').style.display = 'none';
                
                // 显示上传成功提示
                alert('照片上传成功！正在发送给AI模型分析...');
                
                // 直接使用photoKey为true，表示使用IndexedDB存储
                analyzePhotosWithAI(photoData, 'indexedDB');
              } catch (error) {
                // 隐藏上传加载动画
                document.getElementById('uploadLoading').style.display = 'none';
                console.error('处理照片数据失败:', error);
                alert('处理照片时出错: ' + error.message);
              }
            }
          };
          
          request.onerror = (error) => {
            console.error(`存储照片 ${i+1} 失败:`, error);
            processedCount++;
          };
        };
        
        reader.readAsDataURL(file);
      }
    }
    
    // 移除压缩函数，保留完整EXIF信息

    function analyzePhotosWithAI(photoData, photosKey) {
      // 显示AI分析加载动画
      document.getElementById('analysisLoading').style.display = 'flex';
      
      // 发送照片数据到后端进行AI分析
      console.log('开始发送请求到后端...');
      console.log('请求数据长度:', photoData.length);
      
      fetch('/analyze-photos', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(photoData)
      })
      .then(response => {
        console.log('响应状态:', response.status);
        console.log('响应头:', response.headers);
        if (!response.ok) {
          throw new Error(`HTTP错误! 状态码: ${response.status}`);
        }
        return response.json();
      })
      .then(result => {
        // 隐藏AI分析加载动画
        document.getElementById('analysisLoading').style.display = 'none';
        
        console.log('AI分析结果:', result);
        // 显示旅行路径卡片，传递photosKey
        showTravelPath(result, photosKey);
      })
      .catch(error => {
        // 隐藏AI分析加载动画
        document.getElementById('analysisLoading').style.display = 'none';
        
        console.error('AI分析失败:', error);
        console.error('错误详情:', error.message);
        alert('照片分析失败，请重试。错误信息: ' + error.message);
        // 如果分析失败且使用了localStorage，移除已存储的照片数据
        if (photosKey) {
          try {
            localStorage.removeItem(photosKey);
          } catch (e) {
            console.error('移除照片数据失败:', e);
          }
        }
      });
    }

    // 卡片滑动功能
    const cardContainer = document.querySelector('.card-container');
    const cards = Array.from(document.querySelectorAll('.card'));
    let currentIndex = 0;
    let startX = 0;
    let currentX = 0;
    let startTime = 0;
    const threshold = 100; // 进一步增加阈值，防止点击时误触发滑动
    const maxRotation = 10; // 最大倾斜角度
    const minSwipeTime = 100; // 最小滑动时间（毫秒），区分点击和滑动

    // 触摸开始
    cardContainer.addEventListener('touchstart', (e) => {
      startX = e.touches[0].clientX;
      startTime = Date.now();
      // 清除过渡效果，使拖动更流畅
      if (cards[currentIndex]) {
        cards[currentIndex].style.transition = 'none';
      }
    });

    // 触摸移动
    cardContainer.addEventListener('touchmove', (e) => {
      currentX = e.touches[0].clientX;
      const diffX = currentX - startX;
      
      // 计算旋转角度
      const rotation = (diffX / 10);
      const clampedRotation = Math.max(-maxRotation, Math.min(maxRotation, rotation));
      
      // 只移动最上面的卡片
      if (cards[currentIndex]) {
        cards[currentIndex].style.transform = `translateX(${diffX}px) rotate(${clampedRotation}deg) scale(1)`;
      }
    });

    // 触摸结束
    cardContainer.addEventListener('touchend', () => {
      const diffX = currentX - startX;
      const swipeTime = Date.now() - startTime;

      // 只有当滑动距离超过阈值且滑动时间足够长时才切换卡片
      if (Math.abs(diffX) > threshold && swipeTime > minSwipeTime) { // 阈值和时间双重判断
        // 根据滑动方向设置旋转角度
        const rotation = diffX > 0 ? 15 : -15;
        const translateX = diffX > 0 ? 200 : -200;
        handleSwipe(translateX, rotation);
      }
      // 没有滑动足够距离或时间太短，重置位置
      else {
        resetCardPosition();
      }
    });

    // 统一滑动处理函数
    function handleSwipe(translateX, rotation) {
      if (!cards[currentIndex]) return;
      
      // 当前卡片移出并弹到后面
      cards[currentIndex].style.transition = 'all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)';
      cards[currentIndex].style.transform = `translateX(${translateX}px) rotate(${rotation}deg) scale(0.85)`;
      cards[currentIndex].style.opacity = '0';
      
      // 根据滑动方向更新索引（循环）
      if (translateX > 0) {
        // 右滑 - 上一张
        currentIndex = (currentIndex - 1 + cards.length) % cards.length;
      } else {
        // 左滑 - 下一张
        currentIndex = (currentIndex + 1) % cards.length;
      }
      
      // 重新排列卡片
      setTimeout(() => {
        rearrangeCards();
      }, 200);
    }

    // 重置卡片位置
    function resetCardPosition() {
      if (!cards[currentIndex]) return;
      
      cards[currentIndex].style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      cards[currentIndex].style.transform = `translateX(0) rotate(0deg) scale(1)`;
      cards[currentIndex].style.opacity = '1';
    }

    // 重新排列卡片
    function rearrangeCards() {
      cards.forEach((card, index) => {
        card.style.transition = 'all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)';
        
        // 计算上一张、当前、下一张的索引
        const prevIndex = (currentIndex - 1 + cards.length) % cards.length;
        const nextIndex = (currentIndex + 1) % cards.length;
        
        if (index === currentIndex) {
          // 当前卡片在中间，z-index最高
          card.style.zIndex = '3';
          card.style.transform = 'translateX(0) translateY(0) rotate(0deg) scale(1)';
          card.style.opacity = '1';
        } else if (index === nextIndex) {
          // 下一张卡片在右侧
          card.style.zIndex = '2';
          card.style.transform = 'translateX(15px) translateY(5px) rotate(2deg) scale(0.98)';
          card.style.opacity = '0.9';
        } else if (index === prevIndex) {
          // 上一张卡片在左侧
          card.style.zIndex = '2';
          card.style.transform = 'translateX(-15px) translateY(5px) rotate(-2deg) scale(0.98)';
          card.style.opacity = '0.9';
        } else {
          // 其他所有卡片都隐藏
          card.style.zIndex = '0';
          card.style.transform = 'translateX(0) translateY(30px) rotate(0deg) scale(0.95)';
          card.style.opacity = '0';
        }
      });
    }

    // 鼠标事件支持（用于桌面测试）
    cardContainer.addEventListener('mousedown', (e) => {
      startX = e.clientX;
      startTime = Date.now();
      // 清除过渡效果
      if (cards[currentIndex]) {
        cards[currentIndex].style.transition = 'none';
      }
      cardContainer.addEventListener('mousemove', mouseMoveHandler);
      cardContainer.addEventListener('mouseup', mouseUpHandler);
    });

    function mouseMoveHandler(e) {
      currentX = e.clientX;
      const diffX = currentX - startX;
      const rotation = (diffX / 10);
      const clampedRotation = Math.max(-maxRotation, Math.min(maxRotation, rotation));
      
      if (cards[currentIndex]) {
        cards[currentIndex].style.transform = `translateX(${diffX}px) rotate(${clampedRotation}deg) scale(1)`;
      }
    }

    function mouseUpHandler(e) {
      const diffX = currentX - startX;
      const swipeTime = Date.now() - startTime;

      // 只有当滑动距离超过阈值且滑动时间足够长时才切换卡片
      if (Math.abs(diffX) > threshold && swipeTime > minSwipeTime) {
        const rotation = diffX > 0 ? 15 : -15;
        const translateX = diffX > 0 ? 200 : -200;
        handleSwipe(translateX, rotation);
      } else {
        resetCardPosition();
      }

      cardContainer.removeEventListener('mousemove', mouseMoveHandler);
      cardContainer.removeEventListener('mouseup', mouseUpHandler);
    }

    function showTravelPath(travelData, photosKey) {
      // 将AI分析结果传递到旅行路径页面
      const travelDataStr = encodeURIComponent(JSON.stringify(travelData.data));
      
      if (photosKey) {
        window.location.href = `travel-path.html?data=${travelDataStr}&photosKey=${photosKey}`;
      } else {
        // 如果没有photosKey，说明未使用localStorage，直接传递关键信息
        window.location.href = `travel-path.html?data=${travelDataStr}`;
      }
    }
  </script>
</body>
</html>
