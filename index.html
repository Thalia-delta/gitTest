<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>极简主界面</title>
  <link rel="stylesheet" href="styles.css" />
  <style>
    /* 加载动画样式 */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .loading-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    /* 吉祥物动画 */
    .mascot-animation {
      width: 80px;
      height: 80px;
    }

    .mascot-animation img {
      width: 100%;
      height: 100%;
      animation: float 2s ease-in-out infinite;
    }

    /* 三个点动画 */
    .dots-animation {
      display: flex;
      gap: 8px;
    }

    .dots-animation .dot {
      width: 10px;
      height: 10px;
      background-color: #333;
      border-radius: 50%;
      animation: float 1.5s ease-in-out infinite;
    }

    .dots-animation .dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .dots-animation .dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    /* 加载文字 */
    .loading-text {
      font-size: 18px;
      color: #333;
      margin-top: 0.5rem;
    }

    /* 浮动动画 */
    @keyframes float {
      0%, 100% {
        transform: translateY(0);
      }
      50% {
        transform: translateY(-10px);
      }
    }
  </style>
</head>

<body>
  <!-- 顶部导航 - 悬浮按钮样式 -->
  <header class="top-nav">
    <div class="nav-toggle" id="navToggle">
      <span class="toggle-icon">☰</span>
    </div>
    <div class="nav-dropdown" id="navDropdown">
      <span class="nav-item active">主界面</span>
      <span class="nav-item" onclick="window.location.href='album.html'">相册集</span>
      <span class="nav-item" onclick="window.location.href='profile.html'">我的</span>
    </div>
  </header>

  <!-- 上传加载动画 -->
  <div class="loading-overlay" id="uploadLoading">
    <div class="loading-content">
      <div class="mascot-animation">
        <img src="Picture\草裙.png" alt="吉祥物">
      </div>
      <div class="dots-animation">
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
      </div>
      <p class="loading-text">加载中...</p>
    </div>
  </div>

  <!-- 大模型分析加载动画 -->
  <div class="loading-overlay" id="analysisLoading">
    <div class="loading-content">
      <div class="mascot-animation">
        <img src="Picture\草裙.png" alt="吉祥物">
      </div>
      <div class="dots-animation">
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
      </div>
      <p class="loading-text">AI分析中...</p>
    </div>
  </div>

  <!-- 主体 -->
  <main class="main">
    <!-- 吉祥物 -->
    <div class="mascot">
      <img src="Picture\草裙.png" alt="mascot">
    </div>

    <!-- 文案 -->
    <p class="greeting">“hi，又去哪里玩了呀？”</p>

    <!-- 滑动卡片 -->
    <div class="card-slider">
      <!-- 左侧滑动提示 -->
      <div class="swipe-hint left">
        <span class="hint-text">左右滑动</span>
        <span class="hint-arrow"><<<</span>
      </div>
      
      <div class="card-container">
        <div class="card new-card" onclick="openPhotoUpload()">
          <span class="plus">＋</span>
          <span>新建回忆</span>
          <input type="file" id="photoInput" multiple accept="image/*" style="display: none;" onchange="handlePhotoUpload(this.files)">
        </div>

      <div class="card">
        <p>上次的旅行</p>
      </div>

      <div class="card">
        <p>周末随拍</p>
      </div>
      
      <div class="card">
        <p>毕业纪念</p>
      </div>
      
      <div class="card">
        <p>美食记录</p>
      </div>
      
      <div class="card">
        <p>城市风光</p>
      </div>
      
      <div class="card">
        <p>自然风景</p>
      </div>
      
      <div class="card">
        <p>家庭聚会</p>
      </div>
      </div>
      
      <!-- 右侧滑动提示 -->
      <div class="swipe-hint right">
        <span class="hint-text">左右滑动</span>
        <span class="hint-arrow">>>></span>
      </div>
    </div>
  </main>

  <script>
    // 导航菜单功能
    const navToggle = document.getElementById('navToggle');
    const navDropdown = document.getElementById('navDropdown');
    let isDropdownOpen = false;
    
    // 切换下拉菜单显示状态
    navToggle.addEventListener('click', () => {
      isDropdownOpen = !isDropdownOpen;
      navDropdown.classList.toggle('show', isDropdownOpen);
    });
    
    // 点击页面其他地方关闭下拉菜单
    document.addEventListener('click', (e) => {
      if (!navToggle.contains(e.target) && !navDropdown.contains(e.target)) {
        isDropdownOpen = false;
        navDropdown.classList.remove('show');
      }
    });

    // 照片上传功能
    function openPhotoUpload() {
      document.getElementById('photoInput').click();
    }

    // 清空所有照片数据
    function clearAllPhotosData() {
      try {
        const keysToRemove = [];
        
        // 找出所有照片相关数据并删除
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key.startsWith('travel_photos_')) {
            keysToRemove.push(key);
          }
        }
        
        keysToRemove.forEach(key => {
          localStorage.removeItem(key);
          console.log('已清理照片数据:', key);
        });
        
        console.log('共清理', keysToRemove.length, '条照片数据');
      } catch (error) {
        console.error('清理照片数据失败:', error);
      }
    }
    
    // 检查localStorage剩余空间的辅助函数
    function getLocalStorageFreeSpace() {
      try {
        const testData = 'x'.repeat(1024); // 1KB测试数据
        let totalUsed = 0;
        
        // 计算已使用空间
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          const value = localStorage.getItem(key);
          totalUsed += (key.length + value.length) * 2; // 每个字符2字节
        }
        
        // 估算总容量（通常为5MB）
        const estimatedTotal = 5 * 1024 * 1024;
        return estimatedTotal - totalUsed;
      } catch (error) {
        console.error('计算剩余空间失败:', error);
        return 0;
      }
    }
    
    function handlePhotoUpload(files) {
      if (!files || files.length === 0) {
        console.log('没有选择照片');
        return;
      }
      
      console.log('开始处理照片...');
      console.log('选中的照片数量:', files.length);
      
      // 显示上传加载动画
      document.getElementById('uploadLoading').style.display = 'flex';
      
      // 清空所有之前存储的照片数据，确保有足够空间
      clearAllPhotosData();
      
      const photoData = [];
      let processedCount = 0;
      
      // 生成唯一标识符，用于存储照片数据
      const photosKey = 'travel_photos_' + Date.now();
      
      // 处理每张照片
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        console.log(`处理照片 ${i+1}/${files.length}: ${file.name}, 大小: ${(file.size/1024/1024).toFixed(2)}MB`);
        
        // 压缩照片以减小文件大小
        compressImage(file, (compressedData) => {
          const photo = {
            id: i,
            name: file.name,
            size: file.size,
            compressedSize: compressedData.length,
            type: file.type,
            data: compressedData,
          };
          
          photoData.push(photo);
          processedCount++;
          
          console.log(`照片 ${i+1} 处理完成，已处理: ${processedCount}/${files.length}`);
          
          // 所有照片处理完成
          if (processedCount === files.length) {
            console.log('所有照片处理完成，开始发送请求...');
            
            try {
              // 计算数据大小
              const dataStr = JSON.stringify(photoData);
              const dataSize = (dataStr.length * 2) / 1024 / 1024; // MB
              console.log('照片数据大小:', dataSize.toFixed(2), 'MB');
              
              // 检查localStorage是否有足够空间
              const freeSpace = getLocalStorageFreeSpace();
              const freeSpaceMB = freeSpace / 1024 / 1024;
              console.log('localStorage剩余空间:', freeSpaceMB.toFixed(2), 'MB');
              
              // 尝试存储到localStorage
              localStorage.setItem(photosKey, dataStr);
              console.log('照片数据已成功存储到localStorage');
              
              // 隐藏上传加载动画
              document.getElementById('uploadLoading').style.display = 'none';
              
              // 显示上传成功提示
              alert('照片上传成功！正在发送给AI模型分析...');
              
              analyzePhotosWithAI(photoData, photosKey);
            } catch (error) {
                // 隐藏上传加载动画
                document.getElementById('uploadLoading').style.display = 'none';
                
                if (error.name === 'QuotaExceededError') {
                  console.error('localStorage容量不足，尝试直接发送数据...');
                  alert('本地存储空间不足，但将尝试直接上传照片。建议减少照片数量或降低照片质量。');
                  // 跳过localStorage存储，直接发送数据
                  analyzePhotosWithAI(photoData, null);
                } else {
                  console.error('存储照片数据失败:', error);
                  alert('处理照片时出错: ' + error.message);
                }
            }
          }
        });
      }
    }
    
    // 照片压缩函数 - 优化压缩参数以减小文件大小
    function compressImage(file, callback) {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          // 创建Canvas用于压缩
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // 降低最大尺寸以减小文件大小
          const MAX_WIDTH = 1280;
          const MAX_HEIGHT = 1280;
          let width = img.width;
          let height = img.height;
          
          if (width > height) {
            if (width > MAX_WIDTH) {
              height = Math.round(height * (MAX_WIDTH / width));
              width = MAX_WIDTH;
            }
          } else {
            if (height > MAX_HEIGHT) {
              width = Math.round(width * (MAX_HEIGHT / height));
              height = MAX_HEIGHT;
            }
          }
          
          canvas.width = width;
          canvas.height = height;
          
          // 绘制压缩后的图像
          ctx.drawImage(img, 0, 0, width, height);
          
          // 降低质量参数以进一步减小文件大小
          const compressedData = canvas.toDataURL(file.type, 0.6);
          callback(compressedData);
        };
        img.src = e.target.result;
      };
      
      reader.readAsDataURL(file);
    }

    function analyzePhotosWithAI(photoData, photosKey) {
      // 显示AI分析加载动画
      document.getElementById('analysisLoading').style.display = 'flex';
      
      // 发送照片数据到后端进行AI分析
      console.log('开始发送请求到后端...');
      console.log('请求数据长度:', photoData.length);
      
      fetch('/analyze-photos', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(photoData)
      })
      .then(response => {
        console.log('响应状态:', response.status);
        console.log('响应头:', response.headers);
        if (!response.ok) {
          throw new Error(`HTTP错误! 状态码: ${response.status}`);
        }
        return response.json();
      })
      .then(result => {
        // 隐藏AI分析加载动画
        document.getElementById('analysisLoading').style.display = 'none';
        
        console.log('AI分析结果:', result);
        // 显示旅行路径卡片，传递photosKey
        showTravelPath(result, photosKey);
      })
      .catch(error => {
        // 隐藏AI分析加载动画
        document.getElementById('analysisLoading').style.display = 'none';
        
        console.error('AI分析失败:', error);
        console.error('错误详情:', error.message);
        alert('照片分析失败，请重试。错误信息: ' + error.message);
        // 如果分析失败且使用了localStorage，移除已存储的照片数据
        if (photosKey) {
          try {
            localStorage.removeItem(photosKey);
          } catch (e) {
            console.error('移除照片数据失败:', e);
          }
        }
      });
    }

    // 卡片滑动功能
    const cardContainer = document.querySelector('.card-container');
    const cards = Array.from(document.querySelectorAll('.card'));
    let currentIndex = 0;
    let startX = 0;
    let currentX = 0;
    let startTime = 0;
    const threshold = 100; // 进一步增加阈值，防止点击时误触发滑动
    const maxRotation = 10; // 最大倾斜角度
    const minSwipeTime = 100; // 最小滑动时间（毫秒），区分点击和滑动

    // 触摸开始
    cardContainer.addEventListener('touchstart', (e) => {
      startX = e.touches[0].clientX;
      startTime = Date.now();
      // 清除过渡效果，使拖动更流畅
      if (cards[currentIndex]) {
        cards[currentIndex].style.transition = 'none';
      }
    });

    // 触摸移动
    cardContainer.addEventListener('touchmove', (e) => {
      currentX = e.touches[0].clientX;
      const diffX = currentX - startX;
      
      // 计算旋转角度
      const rotation = (diffX / 10);
      const clampedRotation = Math.max(-maxRotation, Math.min(maxRotation, rotation));
      
      // 只移动最上面的卡片
      if (cards[currentIndex]) {
        cards[currentIndex].style.transform = `translateX(${diffX}px) rotate(${clampedRotation}deg) scale(1)`;
      }
    });

    // 触摸结束
    cardContainer.addEventListener('touchend', () => {
      const diffX = currentX - startX;
      const swipeTime = Date.now() - startTime;

      // 只有当滑动距离超过阈值且滑动时间足够长时才切换卡片
      if (Math.abs(diffX) > threshold && swipeTime > minSwipeTime) { // 阈值和时间双重判断
        // 根据滑动方向设置旋转角度
        const rotation = diffX > 0 ? 15 : -15;
        const translateX = diffX > 0 ? 200 : -200;
        handleSwipe(translateX, rotation);
      }
      // 没有滑动足够距离或时间太短，重置位置
      else {
        resetCardPosition();
      }
    });

    // 统一滑动处理函数
    function handleSwipe(translateX, rotation) {
      if (!cards[currentIndex]) return;
      
      // 当前卡片移出并弹到后面
      cards[currentIndex].style.transition = 'all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)';
      cards[currentIndex].style.transform = `translateX(${translateX}px) rotate(${rotation}deg) scale(0.85)`;
      cards[currentIndex].style.opacity = '0';
      
      // 根据滑动方向更新索引（循环）
      if (translateX > 0) {
        // 右滑 - 上一张
        currentIndex = (currentIndex - 1 + cards.length) % cards.length;
      } else {
        // 左滑 - 下一张
        currentIndex = (currentIndex + 1) % cards.length;
      }
      
      // 重新排列卡片
      setTimeout(() => {
        rearrangeCards();
      }, 200);
    }

    // 重置卡片位置
    function resetCardPosition() {
      if (!cards[currentIndex]) return;
      
      cards[currentIndex].style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      cards[currentIndex].style.transform = `translateX(0) rotate(0deg) scale(1)`;
      cards[currentIndex].style.opacity = '1';
    }

    // 重新排列卡片
    function rearrangeCards() {
      cards.forEach((card, index) => {
        card.style.transition = 'all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)';
        
        // 计算上一张、当前、下一张的索引
        const prevIndex = (currentIndex - 1 + cards.length) % cards.length;
        const nextIndex = (currentIndex + 1) % cards.length;
        
        if (index === currentIndex) {
          // 当前卡片在中间，z-index最高
          card.style.zIndex = '3';
          card.style.transform = 'translateX(0) translateY(0) rotate(0deg) scale(1)';
          card.style.opacity = '1';
        } else if (index === nextIndex) {
          // 下一张卡片在右侧
          card.style.zIndex = '2';
          card.style.transform = 'translateX(15px) translateY(5px) rotate(2deg) scale(0.98)';
          card.style.opacity = '0.9';
        } else if (index === prevIndex) {
          // 上一张卡片在左侧
          card.style.zIndex = '2';
          card.style.transform = 'translateX(-15px) translateY(5px) rotate(-2deg) scale(0.98)';
          card.style.opacity = '0.9';
        } else {
          // 其他所有卡片都隐藏
          card.style.zIndex = '0';
          card.style.transform = 'translateX(0) translateY(30px) rotate(0deg) scale(0.95)';
          card.style.opacity = '0';
        }
      });
    }

    // 鼠标事件支持（用于桌面测试）
    cardContainer.addEventListener('mousedown', (e) => {
      startX = e.clientX;
      startTime = Date.now();
      // 清除过渡效果
      if (cards[currentIndex]) {
        cards[currentIndex].style.transition = 'none';
      }
      cardContainer.addEventListener('mousemove', mouseMoveHandler);
      cardContainer.addEventListener('mouseup', mouseUpHandler);
    });

    function mouseMoveHandler(e) {
      currentX = e.clientX;
      const diffX = currentX - startX;
      const rotation = (diffX / 10);
      const clampedRotation = Math.max(-maxRotation, Math.min(maxRotation, rotation));
      
      if (cards[currentIndex]) {
        cards[currentIndex].style.transform = `translateX(${diffX}px) rotate(${clampedRotation}deg) scale(1)`;
      }
    }

    function mouseUpHandler(e) {
      const diffX = currentX - startX;
      const swipeTime = Date.now() - startTime;

      // 只有当滑动距离超过阈值且滑动时间足够长时才切换卡片
      if (Math.abs(diffX) > threshold && swipeTime > minSwipeTime) {
        const rotation = diffX > 0 ? 15 : -15;
        const translateX = diffX > 0 ? 200 : -200;
        handleSwipe(translateX, rotation);
      } else {
        resetCardPosition();
      }

      cardContainer.removeEventListener('mousemove', mouseMoveHandler);
      cardContainer.removeEventListener('mouseup', mouseUpHandler);
    }

    function showTravelPath(travelData, photosKey) {
      // 将AI分析结果传递到旅行路径页面
      const travelDataStr = encodeURIComponent(JSON.stringify(travelData.data));
      
      if (photosKey) {
        window.location.href = `travel-path.html?data=${travelDataStr}&photosKey=${photosKey}`;
      } else {
        // 如果没有photosKey，说明未使用localStorage，直接传递关键信息
        window.location.href = `travel-path.html?data=${travelDataStr}`;
      }
    }
  </script>
</body>
</html>
