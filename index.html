<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>极简主界面</title>
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <!-- 顶部导航 - 悬浮按钮样式 -->
  <header class="top-nav">
    <div class="nav-toggle" id="navToggle">
      <span class="toggle-icon">☰</span>
    </div>
    <div class="nav-dropdown" id="navDropdown">
      <span class="nav-item active">主界面</span>
      <span class="nav-item" onclick="window.location.href='album.html'">相册集</span>
      <span class="nav-item" onclick="window.location.href='profile.html'">我的</span>
    </div>
  </header>

  <!-- 主体 -->
  <main class="main">
    <!-- 吉祥物 -->
    <div class="mascot">
      <img src="Picture\草裙.png" alt="mascot">
    </div>

    <!-- 文案 -->
    <p class="greeting">“hi，又去哪里玩了呀？”</p>

    <!-- 滑动卡片 -->
    <div class="card-slider">
      <!-- 左侧滑动提示 -->
      <div class="swipe-hint left">
        <span class="hint-text">左右滑动</span>
        <span class="hint-arrow"><<<</span>
      </div>
      
      <div class="card-container">
        <div class="card new-card" onclick="openPhotoUpload()">
          <span class="plus">＋</span>
          <span>新建回忆</span>
          <input type="file" id="photoInput" multiple accept="image/*" style="display: none;" onchange="handlePhotoUpload(this.files)">
        </div>

      <div class="card">
        <p>上次的旅行</p>
      </div>

      <div class="card">
        <p>周末随拍</p>
      </div>
      
      <div class="card">
        <p>毕业纪念</p>
      </div>
      
      <div class="card">
        <p>美食记录</p>
      </div>
      
      <div class="card">
        <p>城市风光</p>
      </div>
      
      <div class="card">
        <p>自然风景</p>
      </div>
      
      <div class="card">
        <p>家庭聚会</p>
      </div>
      </div>
      
      <!-- 右侧滑动提示 -->
      <div class="swipe-hint right">
        <span class="hint-text">左右滑动</span>
        <span class="hint-arrow">>>></span>
      </div>
    </div>
  </main>

  <script>
    // 导航菜单功能
    const navToggle = document.getElementById('navToggle');
    const navDropdown = document.getElementById('navDropdown');
    let isDropdownOpen = false;
    
    // 切换下拉菜单显示状态
    navToggle.addEventListener('click', () => {
      isDropdownOpen = !isDropdownOpen;
      navDropdown.classList.toggle('show', isDropdownOpen);
    });
    
    // 点击页面其他地方关闭下拉菜单
    document.addEventListener('click', (e) => {
      if (!navToggle.contains(e.target) && !navDropdown.contains(e.target)) {
        isDropdownOpen = false;
        navDropdown.classList.remove('show');
      }
    });

    // 照片上传功能
    function openPhotoUpload() {
      document.getElementById('photoInput').click();
    }

    function handlePhotoUpload(files) {
      if (!files || files.length === 0) {
        console.log('没有选择照片');
        return;
      }
      
      console.log('开始处理照片...');
      console.log('选中的照片数量:', files.length);
      
      const photoData = [];
      let processedCount = 0;
      
      // 生成唯一标识符，用于存储照片数据
      const photosKey = 'travel_photos_' + Date.now();
      
      // 处理每张照片
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        console.log(`处理照片 ${i+1}/${files.length}: ${file.name}, 大小: ${file.size/1024/1024}MB`);
        
        // 压缩照片以减小文件大小
        compressImage(file, (compressedData) => {
          const photo = {
            id: i,
            name: file.name,
            size: file.size,
            compressedSize: compressedData.length,
            type: file.type,
            data: compressedData,
            // 这里可以添加更多信息
          };
          
          photoData.push(photo);
          processedCount++;
          
          console.log(`照片 ${i+1} 处理完成，已处理: ${processedCount}/${files.length}`);
          
          // 所有照片处理完成
          if (processedCount === files.length) {
            console.log('所有照片处理完成，开始发送请求...');
            // 将照片数据存储到localStorage (使用之前生成的photosKey)
            localStorage.setItem(photosKey, JSON.stringify(photoData));
            analyzePhotosWithAI(photoData, photosKey);
          }
        });
      }
    }
    
    // 照片压缩函数
    function compressImage(file, callback) {
      const reader = new FileReader();
      
      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          // 创建Canvas用于压缩
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // 设置压缩后的尺寸（最大1920px）
          const MAX_WIDTH = 1920;
          const MAX_HEIGHT = 1920;
          let width = img.width;
          let height = img.height;
          
          if (width > height) {
            if (width > MAX_WIDTH) {
              height = height * (MAX_WIDTH / width);
              width = MAX_WIDTH;
            }
          } else {
            if (height > MAX_HEIGHT) {
              width = width * (MAX_HEIGHT / height);
              height = MAX_HEIGHT;
            }
          }
          
          canvas.width = width;
          canvas.height = height;
          
          // 绘制压缩后的图像
          ctx.drawImage(img, 0, 0, width, height);
          
          // 转换为Base64格式
          const compressedData = canvas.toDataURL(file.type, 0.7);
          callback(compressedData);
        };
        img.src = e.target.result;
      };
      
      reader.readAsDataURL(file);
    }

    function analyzePhotosWithAI(photoData, photosKey) {
      // 发送照片数据到后端进行AI分析
      console.log('开始发送请求到后端...');
      console.log('请求数据长度:', photoData.length);
      
      fetch('/analyze-photos', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(photoData)
      })
      .then(response => {
        console.log('响应状态:', response.status);
        console.log('响应头:', response.headers);
        if (!response.ok) {
          throw new Error(`HTTP错误! 状态码: ${response.status}`);
        }
        return response.json();
      })
      .then(result => {
        console.log('AI分析结果:', result);
        // 显示旅行路径卡片，传递photosKey
        showTravelPath(result, photosKey);
      })
      .catch(error => {
        console.error('AI分析失败:', error);
        console.error('错误详情:', error.message);
        alert('照片分析失败，请重试。错误信息: ' + error.message);
        // 如果分析失败，移除已存储的照片数据
        localStorage.removeItem(photosKey);
      });
    }

    // 卡片滑动功能
    const cardContainer = document.querySelector('.card-container');
    const cards = Array.from(document.querySelectorAll('.card'));
    let currentIndex = 0;
    let startX = 0;
    let currentX = 0;
    let startTime = 0;
    const threshold = 100; // 进一步增加阈值，防止点击时误触发滑动
    const maxRotation = 10; // 最大倾斜角度
    const minSwipeTime = 100; // 最小滑动时间（毫秒），区分点击和滑动

    // 触摸开始
    cardContainer.addEventListener('touchstart', (e) => {
      startX = e.touches[0].clientX;
      startTime = Date.now();
      // 清除过渡效果，使拖动更流畅
      if (cards[currentIndex]) {
        cards[currentIndex].style.transition = 'none';
      }
    });

    // 触摸移动
    cardContainer.addEventListener('touchmove', (e) => {
      currentX = e.touches[0].clientX;
      const diffX = currentX - startX;
      
      // 计算旋转角度
      const rotation = (diffX / 10);
      const clampedRotation = Math.max(-maxRotation, Math.min(maxRotation, rotation));
      
      // 只移动最上面的卡片
      if (cards[currentIndex]) {
        cards[currentIndex].style.transform = `translateX(${diffX}px) rotate(${clampedRotation}deg) scale(1)`;
      }
    });

    // 触摸结束
    cardContainer.addEventListener('touchend', () => {
      const diffX = currentX - startX;
      const swipeTime = Date.now() - startTime;

      // 只有当滑动距离超过阈值且滑动时间足够长时才切换卡片
      if (Math.abs(diffX) > threshold && swipeTime > minSwipeTime) { // 阈值和时间双重判断
        // 根据滑动方向设置旋转角度
        const rotation = diffX > 0 ? 15 : -15;
        const translateX = diffX > 0 ? 200 : -200;
        handleSwipe(translateX, rotation);
      }
      // 没有滑动足够距离或时间太短，重置位置
      else {
        resetCardPosition();
      }
    });

    // 统一滑动处理函数
    function handleSwipe(translateX, rotation) {
      if (!cards[currentIndex]) return;
      
      // 当前卡片移出并弹到后面
      cards[currentIndex].style.transition = 'all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)';
      cards[currentIndex].style.transform = `translateX(${translateX}px) rotate(${rotation}deg) scale(0.85)`;
      cards[currentIndex].style.opacity = '0';
      
      // 根据滑动方向更新索引（循环）
      if (translateX > 0) {
        // 右滑 - 上一张
        currentIndex = (currentIndex - 1 + cards.length) % cards.length;
      } else {
        // 左滑 - 下一张
        currentIndex = (currentIndex + 1) % cards.length;
      }
      
      // 重新排列卡片
      setTimeout(() => {
        rearrangeCards();
      }, 200);
    }

    // 重置卡片位置
    function resetCardPosition() {
      if (!cards[currentIndex]) return;
      
      cards[currentIndex].style.transition = 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
      cards[currentIndex].style.transform = `translateX(0) rotate(0deg) scale(1)`;
      cards[currentIndex].style.opacity = '1';
    }

    // 重新排列卡片
    function rearrangeCards() {
      cards.forEach((card, index) => {
        card.style.transition = 'all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1)';
        
        // 计算上一张、当前、下一张的索引
        const prevIndex = (currentIndex - 1 + cards.length) % cards.length;
        const nextIndex = (currentIndex + 1) % cards.length;
        
        if (index === currentIndex) {
          // 当前卡片在中间，z-index最高
          card.style.zIndex = '3';
          card.style.transform = 'translateX(0) translateY(0) rotate(0deg) scale(1)';
          card.style.opacity = '1';
        } else if (index === nextIndex) {
          // 下一张卡片在右侧
          card.style.zIndex = '2';
          card.style.transform = 'translateX(15px) translateY(5px) rotate(2deg) scale(0.98)';
          card.style.opacity = '0.9';
        } else if (index === prevIndex) {
          // 上一张卡片在左侧
          card.style.zIndex = '2';
          card.style.transform = 'translateX(-15px) translateY(5px) rotate(-2deg) scale(0.98)';
          card.style.opacity = '0.9';
        } else {
          // 其他所有卡片都隐藏
          card.style.zIndex = '0';
          card.style.transform = 'translateX(0) translateY(30px) rotate(0deg) scale(0.95)';
          card.style.opacity = '0';
        }
      });
    }

    // 鼠标事件支持（用于桌面测试）
    cardContainer.addEventListener('mousedown', (e) => {
      startX = e.clientX;
      startTime = Date.now();
      // 清除过渡效果
      if (cards[currentIndex]) {
        cards[currentIndex].style.transition = 'none';
      }
      cardContainer.addEventListener('mousemove', mouseMoveHandler);
      cardContainer.addEventListener('mouseup', mouseUpHandler);
    });

    function mouseMoveHandler(e) {
      currentX = e.clientX;
      const diffX = currentX - startX;
      const rotation = (diffX / 10);
      const clampedRotation = Math.max(-maxRotation, Math.min(maxRotation, rotation));
      
      if (cards[currentIndex]) {
        cards[currentIndex].style.transform = `translateX(${diffX}px) rotate(${clampedRotation}deg) scale(1)`;
      }
    }

    function mouseUpHandler(e) {
      const diffX = currentX - startX;
      const swipeTime = Date.now() - startTime;

      // 只有当滑动距离超过阈值且滑动时间足够长时才切换卡片
      if (Math.abs(diffX) > threshold && swipeTime > minSwipeTime) {
        const rotation = diffX > 0 ? 15 : -15;
        const translateX = diffX > 0 ? 200 : -200;
        handleSwipe(translateX, rotation);
      } else {
        resetCardPosition();
      }

      cardContainer.removeEventListener('mousemove', mouseMoveHandler);
      cardContainer.removeEventListener('mouseup', mouseUpHandler);
    }

    function showTravelPath(travelData, photosKey) {
      // 将AI分析结果和照片存储键传递到旅行路径页面
      const travelDataStr = encodeURIComponent(JSON.stringify(travelData.data));
      window.location.href = `travel-path.html?data=${travelDataStr}&photosKey=${photosKey}`;
    }
  </script>
</body>
</html>
